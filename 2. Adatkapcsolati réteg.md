### Keretezés
A bitfolyamot keretekre osszuk, a keretekhez ellenőrző összeget fogunk rendelni mellyel a hibákat fel fogjuk tudni ismerni és akár javítani.
- Bájt alapú
	- az adatot bájt szinten kezeljük
	- kiegészítjük a fejlécet, mely tartalmazza a fejléc hosszát
	- Bájtbeszúrás: flagbájttal azonosítjuk a keret elejét és végét, a kettő között van az adat
		- Mi van ha flag szerepel az adatban? Escape bájtot szúrunk elé
		- escape-et is escape-elni kell
- Bit alapú
	- Bitbeszúrás: minden keret speciális bitmintával kezdődik
	- minden 11111 után beszúrunk egy 0-t, fogadó oldalon minden 5. 1-es utáni 0-t eldobujuk mert aaz egy beszúrás eredménye volt
	- ha 6 db 1-es van és utána 0 akkor az a keret vége, ha 1-es akkor valami hiba van, eldobjuk a keretet
- Órajel alapú
	- SONET (Syncronous Optical Network): a keretméret rögzített, csak a keret eleje van egy speciális bitmintával jelölve, onnantól pedig tudjuk hogy hány bájtot kell fogadni (pl.: sts-1 esetén 810 bájt a kerethossz)
### Hiba felügyelet
A fizikai világ eredendően zajos
- egyszerű bithiba: az adategység egyetlenegy bitje változik
- csoportos bithiba (burst error): bitek egy oylan folytonos sorozata melynek első és utolsó szimbóluma hibás, és ezen belül nem létezik olyan m(ez az m paraméter a védelmi övezet aka. guard band) hosszú részsorozat amit helyesen fogadtunk volna a burst-ön belül, ha pl az m=1 akkor nem tudunk kiválasztani úgy 1 bitet ami nem hibás
### Hibadetektálás: 
- Naív hibadetektálás: kópia minden egyes keretből, de dupla méretű üzenetben kétszer akkora a meghibásodás lehetősége
- Paritásbit: egy extra bitet adunk a sorozathoz úgy, hogy az egyes bitek száma végül páros legyen
	- 1 bithiba detektálható
	- 2 már nem, burstös hibák esetén nem használható
### Hibavezérlés(javtás):
A hibavezérléshez redundancia szükséges
- hibajavító kódok:  FEC(Forward Error Correction): előre hibajavítás, kevésbe megbízható csatonán célszerűbb
- hiba detektálás és újraküldés: Automatic Repeat Request (ARQ), megbízható csatornákban olcsóbb
#### Hamming-távolság:
két kódszó között hány bitnek kell eltérnie ahhoz hogy egy másik legális kódszót kapjunk, teljesíti a háromszög egyenlőséget, a legrosszabb esetet fejezi ki
	$d(S) = 1$ esetén nem tudjuk detektálni a hibát
	$d(S) eq 2$ esetén tudjuk detektálni a hibát, de nem tudjuk javítani
Hamming-korlát bináris könyvre: 
	Minden $C subset.eq {0,1}^n$ kód, ahol $d(S) eq k (in NN_+)$ Akkor teljesül hogy: $|C|sum_(i=0)^(|{K-1}/2|) mat(n; i) lt.eq 2^n$  
	(Nem kell a viszgán!) Bizonyítás: 
		1. Pontosan $mat(n;i)$ bitszó létezik amely tetszőleges $x in C$ kódszótól pontosan $i in NN^+$ távolságra helyezkedik el
		2. Pontosan $sum_(i=0)^(|{K-1}/2|) mat(n;i)$ bitzsó létezik mely tetszőleges $x in C$ kódszótól legfeljebb $|\frac{(k-1)}{2}|$ távolságra helyezkedik el
		3. Tetszőleges $x in {0,1}^n$ bitszóhoz legfeljebb egy legális $u in C$ kódszó létezhet, melyre $d(x,u) \leq \frac{k-1}{2}$ teljesül
	d hiba felismeréséhez d+1 Hamming-távolság szükséges.
	d hiba javításához 2d+1 Hamming-távolság szükséges.
#### Paritás bit használata
- Egy paritásbit használat módszer: 1 hibát vagyunk képesek detektálni, 0-t vagyunk képesek javítani
- Hamming-kód:
	- kódszó bitjeit indexeljük, 1-el kezdünk
	- minden 2 egészhatvány sorszámú pozíciói lesznek az ellenőrzőbitek
	- k pozíciót írjuk fel 2 hatványok összegeként $arrow$ a felbontásban lévő pzíciók megadják melyik bitek ellenőrzik
	- https://youtu.be/qJ2Gaz_3Gmo?list=PL3GWppGvUS1q8JXHWmdN8SGVFpO4KtyS2&t=3051
	- ![[Pasted image 20250525154436.png]]
	- A vevő az üzenet megérkezésekor 0-ra állítja a számlálóját, majd megvizsgálja a paritásbiteket, ha k-adik partiás nem jó akkor hozzáad k-t
		- ha a számláló 0 marad akkor a kapott üzenet helyes, ha nem nulla, akkor a hibás bit sorszámát tartalmazza, ha pl az első, második és nyolcadik bit helytelen, akkor  a megváltozott bit a 11.
		- ![[Pasted image 20250525154748.png]]
Hibajelző kódok: 
	Polinom-kód, avagy ciklickus redundancia(CRC):
	![[Pasted image 20250525161244.png]]
### Forgalomszabályozás:
- gyors adó, lassú vevő problémája (elárasztás)
- még hibamentes átvitel esetén se lesz képes a vevő fogadni a kereteket
Megoldási lehetőségek:
- visszacsatolás alapú ( feedback-based flow control): engedélyezés
- sebesség alapú(rate-based flow control): protokollba intergált sebességkorlát, adatkapcsolati réteg nem használja
#### Elemi adatkapcsolati protokollok:
Felvetések:
- a fizikai, az adatkapcsolati és hálózati réteg független folyamatok, melyek üzeneteken keresztül kommunikálnak egymással
- az A gép megbízható, összeköttetés alapú szolgáltatás alkalmazásával akar a B gépnek egy hosszú üzenetet küldeni
- A gépek nem fagynak le
- Adatkapcsolati fejrészben vezérlési információk; adatkapcsolati lábrészben ellenörző réteg
Kommunikációs fajták:
- **szimplex kommunikáció:** a kommunikáció pusztán egy irányba lehetséges
	- ideális esetben:
		- az adó és vevő rétegek mindig készen állnak
		- feldolgozási időktől eltekintünk
		- végtelen puffer-terület
		- nincs sem sorszám, sem nyugta, a küldő végtelen ciklusban küldi az üzeneteket
	- zajos csatornánál
		- mindig készen állnak a rétegek
		- a vevőnek $Delta t$ időre van szüksége a feldolgozásra
		- a kommunikácós csatorna hibázhat
		- a küldő egyseével küldi a kereteket és addig nem küld újat amíg nyugtát nem kap a vevőtől egy megadott hatíridőn belül, ha lejár az idő ismét elküldi
		- a vevő ha hiba van, nem küld nyugtát és eldobja a keretet
	- a duplikátumok elkerülése miatt sorzsámokat vezetünk be (Alternáló-Bit Protokoll ABP)
	- a küldő elküldi az üzenetet a sorszám mod 2-vel
	- hatékonyság javítása: több üzenetet küldünk egyszerre a következő ábra mintájára:
		![[Pasted image 20250525172321.png]]
	- Csúszó ablak protokollok: 
		- egy időpillanatban több keretet küldünk ki max, a küldő max az ablakméretnyi nyugtázatlan keretnyi nyugtázatlan keret küldése engedélyezett, és a keretbe írjuk a keret sorszámát, ami a sorozatbeli pozíciója, és ha elértük a legnagyobb sorszámot újraindítjuk
		- a vevő kommutatív nyugtát használ, mely egyszerre több kerete nyugtáz
		- **Piggyback-módszer:** a kimenő nyugtákat késleltetjük, hogy rá tudjunk akasztani a következő kimenő adatkeretre (ack mező használata)
		- **pipelining**: Ha az adatsebesség és az RTT(átfordulási idő) sorozata nagy, akkor érdemes nagyméretű ablakot alkalmazni
		- **Visszalépés N-nel**: Az összes hibás keret utáni keretet eldobja és nyugtát sem küld róluk, ekkor a küldő a hibás kerettel kezdve a összeset elküldi újra
		- **Szelektív ismétlés**: a hibás kereteket eldobja, de az utánalévőket puffereli, az adó a legrégebbi nyugtázatlan keretet küldi el
- 
- **fél-dupplex kommunikáció:** mindkét irányba folyhat a kommunikáció,  de egy szerre csak egy irányba lehet aktív
- **duplex kommunikáció:** mindkét irányba folyhat a kommunikáció szimultán
**Közeg hozzáférés:** ethernet és wifi többszörös hozzáférést biztpsítanak a közeghez, az átvileti közegen több résztvevő osztozik, az egyidejű átvitel ütközést okoz $arrow$ szabályokat kell létrehozni a közeg megosztására, stratégiákat az ütközések észlelésséhez, elkerüléséhez, feloldásához
**Csatornakiosztás:** 
- statikus módon
- dinamikus módon
	- verseny vagy ütközés alapú módon: pl.: ALOHA, CSMA, CSMA/CD
		- ALOHA: Ha van üzenet, elküldi, az állomások egyből küldenek, a fogadók mindent nyugtáznak, ha nincs nyugta újraküldik
	- verseny-mentes protokollokkal (bittérkép-alapú, bináris visszaszámlálás)
	- korlátozott verseny protokollokkal (adaptív fa protokollok)
	- dinamikus csatornakiosztás folyamata:
		1. állomás modell
			- N terminál/állomás
			- annak a valószínűsége hogy $Delta t$ idő alatt a csomat megérkezik: $lambda Delta t$ ahol a $lambda$ az érkezési folyam rátája
		2. egyetlen csatorna feltételezése
			- minden állomás egyenrangú
			- minden kommunikáció ugyanazon a csatornán folyik
			- minden állomás tud ezen a csatornán csomagot küldeni és fogadni
		3. ütközés feltételezése
			- ha két keret egyidőben kerül átvitelre, akkor átlapolódnak és az eredményül kapott jel értelmetlen
		4. folytonos időmodell vs diszkrét időmodell
			- folytonos: Mindegyik állomás tetszőleges időpotban megkezdheti a küldésre kész keretének sugárzását
			- diszkrét: az időt diszkrté résszekre osztjuk, a keret továbbítás csak időrés elején lehetséges, ez lehet üres, sikeres, ütközéses
		5. vivőjel érzékelés vs nincs vivőjel érzékelés
			- nincs: az állomások nem tudják megviszgálni a közös csatorna állapotát így csak egyszerűen elkezdenek küldeni ha van rá lehetőségük
			- van: tudják viszgálni a csatorna állapotáta küldés előtt. A csatorna lehet **foglalt vagy szabad**
Terhelés (G):
- a protokoll által kezelendő csomagok száma egy időegység alatt (beérkező kérések)
- G >1: túlterhelés
- a csatorna egy kérést tud elvezetni
- ideális esteben 
	- Ha G<1, S=G
	- Ha $G gt.eq 1$, S=1
	- ahol egy csomag küldése egy időegységet vesz igénybe
### Teljesítmény elemzés
Possion folyam:
- a véletlen érkezések egyik modellje
- feltételezések:
	- az érkezés valószínűsége egy rövid $Delta t$ intervallum alatt arányos az intervallum hosszával és nem függ az intervallum kezdetétől (= **memória nélküli tulajdonság**)
	- Annak a valószínűsége hogy  több érkezés történik egy rövid $Delta t$ intervallum alatt közelít a nullához
	- $lambda$ az érkezési ráta
	- (nem kell viszgára!) $P_{k}(t) = \frac{\lambda t^k e^{-\lambda t}}{k!}$
ALOHA viszgálata:
1. Jelölés:
	- $T_f eq$ keret-idő (feldolgozási, átviteli és propagációs idő)
	- S: A sikeres keret átvitelek átlagos száma $T_f$ idő alatt (throughput)
	- G: $T_f$ idő alatti összes átviteli kísérletek átlagos száma
	- D: Egy keret küldésre kész állapota és sikeres átvitele között eltelt átlagos idő
2. Feltételezések:
	- Mindeen keret azonos méretű
	- a csatorna zajmentes, hibát csak az ütközések okoznak
	- a keretek nem kerülnek sorokba az egyedi állomásokon
	- egy csatorna possion-folyamként viselkedik
- A sebezhetőségi idő egy keret sikeres átviteléhez: $2 T_f$
- Tehát a "jó" átvitel valószínűsége megegyezik azzal hogy a sebezhetőségi idő alatt nem érkezik be keret
	- ![[Pasted image 20250526145958.png]]
	- ![[Pasted image 20250526150017.png]]
Réselt ALOHA:
- a csatornát azonos időrésekre bontjuk: csak akkor küldhetünk keretet, ha az időrések határán vagyunk
![[Pasted image 20250526150157.png]]
Adatszóró (broadcast) Ethernet:
- ma már switchelt hálózataink vannak, régen adatszóró technológia volt
- ![[Pasted image 20250526150322.png]]
- A jel végighalad a teljes csatornán
- CSMA (Carrier Sense Multiple Access) protokoll:
	- vivője érzékelés, minden állomás képes belehallgatni a csatornába hogy valamely más állomás éppen használja-e
	1. 1-perzisztens CSMA
		- keret leadása előtt belehallgat a csatornába
		- ha foglalt addig vár amíg fel nem szabadul, ha szabad elküldi (perzisztens)
		- ha ütközés történik az állomás véletlen ideig vár
	2. nem perzisztens CSMA protokoll
		- mohóság elkerülése
		 - keret leadása előtt belehallgat a csatornába, ha foglalt, véletlen ideig vár (nem figyeli a csatornát) majd újra belehallgat
		 - ha szabad akkor küld
	3. p-perzisztens CSMA protokoll
		- adáskész állapotban belehallgat a csatornába
		- ha foglalt akkor vár a következ időrésig majd megismétli az algoritmust
		- ha szabad akkor p valószínűséggel küld, illetve 1-p valószínűséggel visszalép a következő időrésig
		- várakozás esetén a következő időrésben megismétli
		- ez addig folytatódik amíg el nem küldi a keretet vagy egy másik állomás nem küld valamit, mert ezt úgy érzékeli mintha ütközés történt volna
- CSMA/CD
	- ütközés-érzékelés esetén lehessen  szakítani az adást (collision detection)
	- minden állomás küldés közben figyeli a csatornát
	- ha ütközést tapasztal akkor megszakítja az adást, véletlen ideig vár majd újra elkezdi leadni a keretet
	- az ütközés detektálás minimális ideje annyi  ami a jelnek  a  két legtávolabbi állomás közötti átvitelének szükséges
	- binary exponensial backoff az újraküldés során
Binary exponential beckoff
- ütközés érzékelésnél a küldő egy "jam" jelet küld
- válassszunk egy k $in$ $[0, 2^n -1]$ egyenletes eloszlás szerint ahol n z az ütközése száma
- várjuk k időegységet (keretidőt) az újraküldésig
- n felős határa 10, 16 sikertelen próbákozás után pedig eldobjuk a keretet
Minimális keretméret
- 64 bájt, az állomásoknak elég időre van szüksége az ütközések detektálásához
- keretméret és kábelhossz:
	![[Pasted image 20250526151816.png]]
Maximális keretméret:
![[Pasted image 20250526151916.png]]
Alapvető bittérkép protokoll: helyfoglalásos
- egy bittérképen jelzik a küldési szándékukat
- majd ezek alapján a következő időszeleteket kiosztjuk, azoknak akik jelezték
- küldési fázis, majd helyfoglalás megint és újra
- a bitvektor nagyon hosszú is lehet
- megoldás: verseny -> mindenki elkezdi sugározni az első bitjét, ha az eredő megegyezik a saját bitjével akkor játékban marad, jön a következő
- probléma: a legnagyobb azonosítójú nyer mindig: megoldás: virtuális azonosítók, minden azonosítót növelünk,a legnagyobbat "nullázzuk"
Adaptív fabejárási protokoll:
- https://youtu.be/uu-uS_AXNw8?list=PL3GWppGvUS1q8JXHWmdN8SGVFpO4KtyS2&t=5132
### Lanok összekapcsolása

A bridge-ek lekorlátozzák az ütközési tartományok méretét. Jelentősen növelik a skálázhatóságot.
A bridge-ek sokkal komplexebb eszközök a huboknál. Memória pufferek, csomagfeldolgozó hardver és routing táblák szüségesek
Bridge: több IEEE 802 LAN-t köt össze a 2. rétegben
A Bridgek BPDU(Configuration Bridge Protocol Data Unit) üzeneteket váltanak a gyökérelem megválasztásához, a legrövidebb út meghatározásához, a next hop állomások és a hozzá tartozó port azonosításához, a feszfához tartozó portok  kiválasztásához
Gyökér választása:
- kezdetben minden switch feltételezi magáról hogy gyökér
- minden irányba küldenek egy BPDU üzenetet
- a fogadott üzenet alapján választ egy új elemet úgy hogy:
	- legkisebb ismert gyökér ID alapján
	- egy új gyökér portot melyik interfész megy a gyökér irányába
	- egy új kijelölt bridge-et ami a következő  állomás a gyökérhez vezető úton
	- felépítés: https://youtu.be/oyKdUeHgPUo?list=PL3GWppGvUS1q8JXHWmdN8SGVFpO4KtyS2&t=1991


